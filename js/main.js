let allRecords1 = [
    {
        conferenceId: "S16TLHO7QA",
        conversationCategory: "Акции и бонусы",
        conversationLink: "https://my.livechatinc.com/archives/S16TLHO7QA",
        conversationTags: ['1-дубли бонус', '1-Бонусная рассылка', '2-Менеджеры Katsubet', '3-Низкий', '4-Простой', '5-Акции и бонусы', '6-Английский', '7- Antony'],
        conversationType: "chat",
        createdAt: "2023-10-01 00:04:22",
        customerEmail: "phonyami007_85@outlook.com",
        customerId: "f23e8e88-67aa-4dc6-a545-6f348a01ab3a",
        operatorNicks: ['Mikola'],
        projectName: "KatsuBet"
    },
    {
        conferenceId: "S16TMH5H2J",
        conversationCategory: "Финансовые операции",
        conversationLink: "https://my.livechatinc.com/archives/S16TMH5H2J",
        conversationTags: ['chatbot', 'chatbot-transfer', '1-депозит неуспешен', '1-платежи', '2-Менеджеры Katsubet', '3-Средний', '4-Простой', '5-Финансовые операции', '6-Английский', '7-Henry'],
        conversationType: "chat",
        createdAt: "2023-10-01 00:10:31",
        customerEmail: "stdennisc@yahoo.com",
        customerId: "ed719be9-dc78-4006-9038-8128ddaf80fe",
        operatorNicks: ['Katsubet Support', 'Dave'],
        projectName: "KatsuBet"
    },
    {
        conferenceId: "S16TMHDNQU",
        conversationCategory: "Макс бет (игры/слоты)",
        conversationLink: "https://my.livechatinc.com/archives/S16TMHDNQU",
        conversationTags: ['chatbot', 'chatbot-transfer', '6-Английский', '4-Простой', '3-Низкий', '5-Акции и бонусы', '7 - Claire', '2-Менеджеры WIN7bit AUSTRALIA', '1-бездеп регистрация'],
        conversationType: "chat",
        createdAt: "2023-10-01 00:14:18",
        customerEmail: "",
        customerId: "47257c9d-0ea3-4ee6-ad70-130a96453448",
        operatorNicks: ['Customer Support', 'Emma'],
        projectName: "7Bit"
    },
    {
        conferenceId: "S4QV5P",
        conversationCategory: "Закрытие аккаунта",
        conversationLink: "https://app.helpdesk.com/tickets/S4QV5P",
        conversationTags: ['1-GAMBLING рассылка', '2-Менеджеры 7bit', '4-Закрытие аккаунта', '5-Английский', '6-Mark', '9-Я. Ангелина', '9-Проблемный кейс уточняем/передаем в сс'],
        conversationType: "ticket",
        createdAt: "2023-10-01T00:37:59+03:00",
        customerEmail: "karoliina.zdravkovic@gmail.com",
        customerId: "karoliina.zdravkovic@gmail.com",
        operatorNicks: ['Silvia'],
        projectName: "7Bit"
    },
    {
        conferenceId: "EQQYYF",
        conversationCategory: "Восстановление доступа",
        conversationLink: "https://app.helpdesk.com/tickets/EQQYYF",
        conversationTags: ['1-Переоткрытие', '2-Менеджеры 7bit', '4-Восстановление доступа', '5-Английский', '6-Pablo', '6-Jamie'],
        conversationType: "ticket",
        createdAt: "2023-10-01T01:12:33+03:00",
        customerEmail: "alexandeteric@gmail.com",
        customerId: "alexandeteric@gmail.com",
        operatorNicks: ['Silvia'],
        projectName: "7Bit"
    },
    {
        conferenceId: "W2U04U",
        conversationCategory: "Акции и бонусы",
        conversationLink: "https://app.helpdesk.com/tickets/W2U04U",
        conversationTags: ['1-Daily cashback', '2-Менеджеры Katsubet', '4-Акции и бонусы', '5-Английский', '7-Henry', '1-UTC', '1-другие условия не выполнены', '7-Ethan', '1-NO REPLY'],
        conversationType: "chat",
        createdAt: "2023-10-01T01:21:56+03:00",
        customerEmail: "rhi_rhi3@hotmail.com",
        customerId: "rhi_rhi3@hotmail.com",
        operatorNicks: ['Olivia'],
        projectName: "Mirax"
    },
    {
        conferenceId: "G7P8UZ",
        conversationCategory: "Другие тикеты",
        conversationLink: "https://app.helpdesk.com/tickets/G7P8UZ",
        conversationTags: ['1-неизвестный вопрос', '2-Менеджеры 7bit', '5-Английский', '6-Mark', '4-Другие тикеты'],
        conversationType: "ticket",
        createdAt: "2023-10-01T01:53:27+03:00",
        customerEmail: "jaysondaze19@gmail.com",
        customerId: "jaysondaze19@gmail.com",
        operatorNicks: ['Silvia'],
        projectName: "7Bit"
    },
    {
        conferenceId: "5DINWJ",
        conversationCategory: "Акции и бонусы",
        conversationLink: "https://app.helpdesk.com/tickets/5DINWJ",
        conversationTags: ['1-бездеп', '2-Менеджеры 7bit', '4-Акции и бонусы', '5-Английский', '6-Mark', '6-Hope'],
        conversationType: "ticket",
        createdAt: "2023-10-01T01:56:41+03:00",
        customerEmail: "ggholdap@icloud.com",
        customerId: "ggholdap@icloud.com",
        operatorNicks: ['Emma'],
        projectName: "7Bit"
    },
    {
        conferenceId: "6BQN9D",
        conversationCategory: "Другие тикеты",
        conversationLink: "https://app.helpdesk.com/tickets/6BQN9D",
        conversationTags: ['1-неизвестный вопрос', '2-Менеджеры Katsubet', '4-Другие тикеты', '5-Английский', '7-Antony'],
        conversationType: "ticket",
        createdAt: "2023-10-01T02:02:24+03:00",
        customerEmail: "valentinaprodan320@gmail.com",
        customerId: "valentinaprodan320@gmail.com",
        operatorNicks: ['Jimmy'],
        projectName: "KatsuBet"
    },
    {
        conferenceId: "FI05HO",
        conversationCategory: "Финансовые операции",
        conversationLink: "https://app.helpdesk.com/tickets/FI05HO",
        conversationTags: ['2-Менеджеры Mirax', '1-депозит успешен', '4-Финансовые операции', '5-Английский', '7-Antony', '1-недостаточная сумма депозита', '1-Lucky Spin'],
        conversationType: "ticket",
        createdAt: "2023-10-01T02:13:47+03:00",
        customerEmail: "kyzerboy123@gmail.com",
        customerId: "kyzerboy123@gmail.com",
        operatorNicks: ['Jimmy'],
        projectName: "Mirax"
    },
    {
        conferenceId: "S16TLHO7QA",
        conversationCategory: "Акции и бонусы",
        conversationLink: "https://my.livechatinc.com/archives/S16TLHO7QA",
        conversationTags: ['1-дубли бонус', '1-Бонусная рассылка', '2-Менеджеры Katsubet', '3-Низкий', '4-Простой', '5-Акции и бонусы', '6-Английский', '7- Antony'],
        conversationType: "chat",
        createdAt: "2023-10-01 00:04:22",
        customerEmail: "phonyami007_85@outlook.com",
        customerId: "f23e8e88-67aa-4dc6-a545-6f348a01ab3a",
        operatorNicks: ['Jimmy'],
        projectName: "KatsuBet"
    },
    {
        conferenceId: "S16TMH5H2J",
        conversationCategory: "Финансовые операции",
        conversationLink: "https://my.livechatinc.com/archives/S16TMH5H2J",
        conversationTags: ['chatbot', 'chatbot-transfer', '1-депозит неуспешен', '1-платежи', '2-Менеджеры Katsubet', '3-Средний', '4-Простой', '5-Финансовые операции', '6-Английский', '7-Henry'],
        conversationType: "chat",
        createdAt: "2023-10-01 00:10:31",
        customerEmail: "stdennisc@yahoo.com",
        customerId: "ed719be9-dc78-4006-9038-8128ddaf80fe",
        operatorNicks: ['Katsubet Support', 'Dave'],
        projectName: "KatsuBet"
    },
    {
        conferenceId: "S16TMHDNQU",
        conversationCategory: "Макс бет (игры/слоты)",
        conversationLink: "https://my.livechatinc.com/archives/S16TMHDNQU",
        conversationTags: ['chatbot', 'chatbot-transfer', '6-Английский', '4-Простой', '3-Низкий', '5-Акции и бонусы', '7 - Claire', '2-Менеджеры WIN7bit AUSTRALIA', '1-бездеп регистрация'],
        conversationType: "chat",
        createdAt: "2023-10-01 00:14:18",
        customerEmail: "",
        customerId: "47257c9d-0ea3-4ee6-ad70-130a96453448",
        operatorNicks: ['Customer Support', 'Emma'],
        projectName: "7Bit"
    },
    {
        conferenceId: "S4QV5P",
        conversationCategory: "Закрытие аккаунта",
        conversationLink: "https://app.helpdesk.com/tickets/S4QV5P",
        conversationTags: ['1-GAMBLING рассылка', '2-Менеджеры 7bit', '4-Закрытие аккаунта', '5-Английский', '6-Mark', '9-Я. Ангелина', '9-Проблемный кейс уточняем/передаем в сс'],
        conversationType: "ticket",
        createdAt: "2023-10-01T00:37:59+03:00",
        customerEmail: "karoliina.zdravkovic@gmail.com",
        customerId: "karoliina.zdravkovic@gmail.com",
        operatorNicks: ['Silvia'],
        projectName: "7Bit"
    },
    {
        conferenceId: "EQQYYF",
        conversationCategory: "Восстановление доступа",
        conversationLink: "https://app.helpdesk.com/tickets/EQQYYF",
        conversationTags: ['1-Переоткрытие', '2-Менеджеры 7bit', '4-Восстановление доступа', '5-Английский', '6-Pablo', '6-Jamie'],
        conversationType: "ticket",
        createdAt: "2023-10-01T01:12:33+03:00",
        customerEmail: "alexandeteric@gmail.com",
        customerId: "alexandeteric@gmail.com",
        operatorNicks: ['Silvia'],
        projectName: "7Bit"
    },
    {
        conferenceId: "W2U04U",
        conversationCategory: "Акции и бонусы",
        conversationLink: "https://app.helpdesk.com/tickets/W2U04U",
        conversationTags: ['1-Daily cashback', '2-Менеджеры Katsubet', '4-Акции и бонусы', '5-Английский', '7-Henry', '1-UTC', '1-другие условия не выполнены', '7-Ethan', '1-NO REPLY'],
        conversationType: "ticket",
        createdAt: "2023-10-01T01:21:56+03:00",
        customerEmail: "rhi_rhi3@hotmail.com",
        customerId: "rhi_rhi3@hotmail.com",
        operatorNicks: ['Dave'],
        projectName: "KatsuBet"
    },
    {
        conferenceId: "G7P8UZ",
        conversationCategory: "Другие тикеты",
        conversationLink: "https://app.helpdesk.com/tickets/G7P8UZ",
        conversationTags: ['1-неизвестный вопрос', '2-Менеджеры 7bit', '5-Английский', '6-Mark', '4-Другие тикеты'],
        conversationType: "ticket",
        createdAt: "2023-10-01T01:53:27+03:00",
        customerEmail: "jaysondaze19@gmail.com",
        customerId: "jaysondaze19@gmail.com",
        operatorNicks: ['Silvia'],
        projectName: "7Bit"
    },
    {
        conferenceId: "5DINWJ",
        conversationCategory: "Акции и бонусы",
        conversationLink: "https://app.helpdesk.com/tickets/5DINWJ",
        conversationTags: ['1-бездеп', '2-Менеджеры 7bit', '4-Акции и бонусы', '5-Английский', '6-Mark', '6-Hope'],
        conversationType: "ticket",
        createdAt: "2023-10-01T01:56:41+03:00",
        customerEmail: "ggholdap@icloud.com",
        customerId: "ggholdap@icloud.com",
        operatorNicks: ['Emma'],
        projectName: "7Bit"
    },
    {
        conferenceId: "6BQN9D",
        conversationCategory: "Другие тикеты",
        conversationLink: "https://app.helpdesk.com/tickets/6BQN9D",
        conversationTags: ['1-неизвестный вопрос', '2-Менеджеры Katsubet', '4-Другие тикеты', '5-Английский', '7-Antony'],
        conversationType: "ticket",
        createdAt: "2023-10-01T02:02:24+03:00",
        customerEmail: "valentinaprodan320@gmail.com",
        customerId: "valentinaprodan320@gmail.com",
        operatorNicks: ['Jimmy'],
        projectName: "KatsuBet"
    },
    {
        conferenceId: "FI05HO",
        conversationCategory: "Финансовые операции",
        conversationLink: "https://app.helpdesk.com/tickets/FI05HO",
        conversationTags: ['2-Менеджеры Mirax', '1-депозит успешен', '4-Финансовые операции', '5-Английский', '7-Antony', '1-недостаточная сумма депозита', '1-Lucky Spin'],
        conversationType: "ticket",
        createdAt: "2023-10-01T02:13:47+03:00",
        customerEmail: "kyzerboy123@gmail.com",
        customerId: "kyzerboy123@gmail.com",
        operatorNicks: ['Jimmy'],
        projectName: "Mirax"
    }
]
let checkList1 = [
    {
        id: "S19VQ01VTT",
        problemDesc: "немає мітки категорії",
        problemLink: "https://my.livechatinc.com/archives/S19VQ01VTT",
        problemType: "EMPTY",
        rmvPosAllList: 3712,
        rmvPosChats: 3712,
        sourse: "chat",
        tags: ['chatbot', 'chatbot-transfer'],
    },
    {
        id: "S19VQ01VTT",
        problemDesc: "немає мітки категорії",
        problemLink: "https://my.livechatinc.com/archives/S19VQ01VTT",
        problemType: "NOREPLYANDCAT",
        rmvPosAllList: 3712,
        rmvPosChats: 3712,
        sourse: "chat",
        tags: ['chatbot', 'chatbot-transfer'],
    },
    {
        id: "S19VQ01VTT",
        problemDesc: "немає мітки категорії",
        problemLink: "https://my.livechatinc.com/archives/S19VQ01VTT",
        problemType: "CATDUPS",
        rmvPosAllList: 3712,
        rmvPosChats: 3712,
        sourse: "chat",
        tags: ['chatbot', 'chatbot-transfer'],
    },
]

const getE = (selector) => document.querySelector(selector);
const proper = (string) => string.charAt(0).toUpperCase() + string.slice(1);

getE('#currYear').innerHTML = new Date().getFullYear();

let catgoryRuNames = {
    Category_1: "Акции и бонусы",
    Category_2: "Безопасность",
    Category_3: "Верификация аккаунта",
    Category_4: "Вопросы по сайту",
    Category_5: "Восстановление доступа",
    Category_6: "Другие тикеты",
    Category_7: "Закрытие аккаунта",
    Category_8: "Изменения аккаунта",
    Category_9: "Макс бет (игры/слоты)",
    Category_10: "Непройденный депозит",
    Category_11: "Партнерство",
    Category_12: "Проблемы по сайту",
    Category_13: "Проблемы с играми",
    Category_14: "Рассылка",
    Category_15: "Регистрация",
    Category_16: "Тест",
    Category_17: "Технические проблемы(кроме бонусов)",
    Category_18: "Финансовые операции",
    Category_19: "Без категорії",
}

let btnProcessFiles = getE('#processFiles');
let btnResetFiles = getE('#resetFiles');

let recordsChats = [],
    recordsTickets = [],
    allRecords = [],
    checkList = [],
    dataByRecordsTickets = [],
    dataByRecordsChats = [];

let isChatsNeeded = false;
let isTicketsNeeded = false;


async function getInfo() {
    console.log("чатів =", recordsChats.length, ", тікетів =", recordsTickets.length, " всього =", allRecords.length);
    console.log(allRecords);
    console.log("Записи на перевірку:", checkList);

    let generalCountContent;
    if (recordsChats.length > 0 && recordsTickets.length > 0) generalCountContent = `чатах та тікетах`;
    else if (recordsChats.length > 0) generalCountContent = `чатах`;
    else if (recordsTickets.length > 0) generalCountContent = `тікетах`;

    getE('.counter-header').style.display = "block";
    getE('.counter-header').innerHTML =
        `Знайдено <span class="counter-number">${allRecords.length}</span> релевантних звернень в ${generalCountContent}.`;
}

// CHECK IF CONVERSATION TYPE NEEDED FUNCTION START
let chatCheckBox = getE("#isChatsNeeded"),
    chatsCover = getE(".chats-cover"),
    chatFileInput = getE("#chatsFileInput"),
    ticketCheckBox = getE("#isTicketsNeeded"),
    ticketsCover = getE(".tickets-cover"),
    ticketFileInput = getE("#ticketsFileInput");

getE(".file-input-container").onchange = () => {
    if (chatCheckBox.checked && ticketCheckBox.checked) {
        chatsCover.style.width = 0;
        ticketsCover.style.width = 0;
        chatFileInput.disabled = false;
        ticketFileInput.disabled = false;
        isChatsNeeded = true;
        isTicketsNeeded = true;
        btnProcessFiles.disabled = true;
    }
    else if (!chatCheckBox.checked && ticketCheckBox.checked) {
        chatsCover.style.width = "100%";
        ticketsCover.style.width = 0;
        chatFileInput.disabled = true;
        ticketFileInput.disabled = false;
        isChatsNeeded = false;
        isTicketsNeeded = true;
        btnProcessFiles.disabled = true;
    }
    else if (chatCheckBox.checked && !ticketCheckBox.checked) {
        chatsCover.style.width = 0;
        ticketsCover.style.width = "100%";
        chatFileInput.disabled = false;
        ticketFileInput.disabled = true;
        isChatsNeeded = true;
        isTicketsNeeded = false;
        btnProcessFiles.disabled = true;
    }
    else {
        chatsCover.style.width = "100%";
        ticketsCover.style.width = "100%";
        chatFileInput.disabled = true;
        ticketFileInput.disabled = true;
        isChatsNeeded = false;
        isTicketsNeeded = false;
        getE('.checkChat').style.opacity = 0;
        getE('.checkTicket').style.opacity = 0;
        chatFileInput.value = "";
        ticketFileInput.value = "";
        btnProcessFiles.disabled = true;
    }
}
// CHECK IF CONVERSATION TYPE NEEDED FUNCTION END

// READ FILES FUNCTION START
async function readFiles() {
    getE('.start-instraction-block').style.display = "none";
    getE('.data-main').classList.remove("hide");
    if (isChatsNeeded && isTicketsNeeded) {
        await readChats();
        await cleanChatRecords();
        await readTickets();
        await cleanTicketRecords();
    }
    else if (isChatsNeeded) {
        await readChats();
        await cleanChatRecords();
    }
    else if (isTicketsNeeded) {
        await readTickets();
        await cleanTicketRecords();
    }
    disableElem();
    if (recordsTickets.length > 0) buildReportOptionArr.recordsTickets = "";
    if (recordsChats.length > 0) buildReportOptionArr.recordsChats = "";
    if (allRecords.length > 0) buildReportOptionArr.allRecords = "";
    if (checkList.length > 0) {
        showAndBuildDialog(checkList, recordsChats);
        buildReportOptionArr.checkList = "";
    }
    else {
        await buildFilteringSection();
    }
}
// READ FILES FUNCTION END

// CHECK IF LOADED FILE IS PROPER FUNCTION START
let checkChat = false, checkTicket = false;
chatFileInput.onchange = () => {
    let inputElem = chatFileInput.files;
    if (inputElem.length > 0) {
        let newFile = inputElem[0];
        let reader = new FileReader();
        reader.readAsText(newFile);
        reader.onload = function (event) {
            let csvdata = event.target.result;
            let get1Line = csvdata.split('\n');
            let getFCell = get1Line[0].substring(1, get1Line[0].length - 1).split('","');
            if (getFCell[0] === "conferenceId") {
                getE('.checkChat').innerHTML = "V";
                getE('.checkChat').style.opacity = 1;
                getE('.checkChat').style.color = "green";
                checkChat = true;
                if (!isTicketsNeeded) {
                    checkTicket = true;
                }
                if (checkChat && checkTicket) {
                    btnProcessFiles.disabled = false;
                    btnResetFiles.disabled = false;
                }
            }
            else if (getFCell[0] !== "conferenceId") {
                getE('.checkChat').innerHTML = "X";
                getE('.checkChat').style.opacity = 1;
                getE('.checkChat').style.color = "red";
                btnProcessFiles.disabled = true;
                btnResetFiles.disabled = false;
                checkChat = false;
            }
        }
    }
}
ticketFileInput.onchange = () => {
    let inputElem = ticketFileInput.files;
    if (inputElem.length > 0) {
        let newFile = inputElem[0];
        let reader = new FileReader();
        reader.readAsText(newFile);
        reader.onload = function (event) {
            let csvdata = event.target.result;
            let get1Line = csvdata.split('\n');
            let getFCell = get1Line[0].substring(1, get1Line[0].length - 1).split('","');
            if (getFCell[0] === "createdAt") {
                getE('.checkTicket').innerHTML = "V";
                getE('.checkTicket').style.opacity = 1;
                getE('.checkTicket').style.color = "green";
                checkTicket = true;
                if (!isChatsNeeded) {
                    checkChat = true;
                }
                if (checkChat && checkTicket) {
                    btnProcessFiles.disabled = false;
                    btnResetFiles.disabled = false;
                }
            }
            else if (getFCell[0] !== "createdAt") {
                getE('.checkTicket').innerHTML = "X";
                getE('.checkTicket').style.opacity = 1;
                getE('.checkTicket').style.color = "red";
                btnProcessFiles.disabled = true;
                btnResetFiles.disabled = false;
                checkTicket = false;
            }
        }
    }
}
// CHECK IF LOADED FILE IS PROPER FUNCTION END

// DISABLE COMPONETS FUNCTION START
function disableElem() {
    chatFileInput.disabled = true;
    ticketFileInput.disabled = true;
    btnProcessFiles.disabled = true;
    getE('.checkChat').style.opacity = 0;
    getE('.checkTicket').style.opacity = 0;
    chatsCover.style.width = "100%";
    ticketsCover.style.width = "100%";
    chatCheckBox.checked = false;
    ticketCheckBox.checked = false;
}
// DISABLE COMPONETS FUNCTION END

// READ CHATS FILE FUNCTION START
async function readChats() {
    let chatsFile = chatFileInput.files;
    if (chatsFile.length > 0) {
        return new Promise((resolve, reject) => {
            let fileWChats = chatsFile[0];
            let reader = new FileReader(); // FileReader Object
            reader.addEventListener('load', file => {
                resolve(dataByRecordsChats = (file.target.result).split('\n'));
            });
            reader.readAsText(fileWChats);
        });
    } else {
        alert("Будь ласка завантажте файл-звіт з чатами в форматі .csv");
    }
}
// READ CHATS FILE FUNCTION END

// READ TICKETS FILE FUNCTION START
async function readTickets() {
    btnProcessFiles.disabled = false;
    let ticketsFile = ticketFileInput.files;
    if (ticketsFile.length > 0) {
        return new Promise((resolve, reject) => {
            let fileWTickets = ticketsFile[0];
            let reader = new FileReader(); // FileReader Object
            reader.addEventListener('load', file => {
                resolve(dataByRecordsTickets = (file.target.result).split('\n'));
            });
            reader.readAsText(fileWTickets);
        });
    } else {
        alert("Будь ласка завантажте файл-звіт з тікетами в форматі .csv");
    }
}
// READ TICKETS FILE FUNCTION END

// REMOVE INPUT FILE/S FUNCTION START
function rmvFiles() {
    chatFileInput.value = "";
    ticketFileInput.value = "";
    chatFileInput.disabled = false;
    ticketFileInput.disabled = false;
    btnProcessFiles.disabled = true;
    btnResetFiles.disabled = true;
    getE('.checkChat').style.opacity = 0;
    getE('.checkTicket').style.opacity = 0;
    chatCheckBox.checked = false;
    chatsCover.style.width = "100%";
    isChatsNeeded = false;
    ticketCheckBox.checked = false;
    ticketsCover.style.width = "100%";
    isChatsNeeded = false;
    dataByRecordsTickets = [];
    dataByRecordsChats = [];
    isChatsNeeded = false;
    isTicketsNeeded = false;
}
// REMOVE INPUT FILE/S FUNCTION END

// CREATE FULL COUNTS LIST FUNCTION START
let cleanRecordsCountObj = {};
async function recordsCounter(dataToCount) {
    // count unique project start
    let allRecordsProject = [];
    for (let i = 0; i < dataToCount.length; i++) {
        allRecordsProject.push(dataToCount[i].projectName)
    }
    let projectsList = allRecordsProject.filter((item, i, arr) => arr.indexOf(item) === i);
    let newProject = [];
    for (let i = 0; i < projectsList.length; i++) {
        let regexProjectName = new RegExp(projectsList[i], "g");
        let projectCount = allRecordsProject.join(" ").match(regexProjectName).length;
        newProject.push({ [projectsList[i]]: projectCount });
    }
    cleanRecordsCountObj.projectsCount = Object.assign({}, newProject);
    // count unique project end

    // count unique conversation types start
    let newConvTypes = [];
    let allRecordsConversationTypes = [];
    for (let i = 0; i < dataToCount.length; i++) {
        allRecordsConversationTypes.push(dataToCount[i].conversationType)
    }
    let conversationTypesList = allRecordsConversationTypes.filter((item, i, arr) => arr.indexOf(item) === i);
    addCountent = "";
    for (let i = 0; i < conversationTypesList.length; i++) {
        let regexConversationTypes = new RegExp(conversationTypesList[i], "g");
        let convTypesCount = allRecordsConversationTypes.join(" ").match(regexConversationTypes).length;
        newConvTypes.push({ [conversationTypesList[i]]: convTypesCount });
    }
    cleanRecordsCountObj.convTypesCount = Object.assign({}, newConvTypes);
    // count unique conversation types end

    // count unique categories start
    let newCategories = [];
    let allRecordsCategory = [];
    for (let i = 0; i < dataToCount.length; i++) {
        allRecordsCategory.push(dataToCount[i].conversationCategory);
        if (dataToCount[i].conversationCategory === "Без категорії") {
        }
    }

    let categoriesList = allRecordsCategory.filter((item, i, arr) => arr.indexOf(item) === i);
    addCountent = "";
    for (let i = 0; i < categoriesList.length; i++) {
        let regexCategoryName;
        if (categoriesList[i] !== undefined) {
            if (categoriesList[i] !== "Макс бет (игры/слоты)" &&
                categoriesList[i] !== "Технические проблемы(кроме бонусов)") {
                regexCategoryName = new RegExp(categoriesList[i], "g");
            }
            if (categoriesList[i] === "Макс бет (игры/слоты)") {
                regexCategoryName = /Макс бет \(игры\/слоты\)/g;
            }
            if (categoriesList[i] === "Технические проблемы(кроме бонусов)") {
                regexCategoryName = /Технические проблемы\(кроме бонусов\)/g;
            }
            let categoriesCount = allRecordsCategory.join(" ").match(regexCategoryName).length;
            newCategories.push({ [categoriesList[i]]: categoriesCount });
        }
    }
    cleanRecordsCountObj.categoriesCount = Object.assign({}, newCategories);
    // count unique categories end

    // count unique agents start
    let newAgents = [];
    let allRecordsAgent = [];
    for (let i = 0; i < dataToCount.length; i++) {
        allRecordsAgent.push(dataToCount[i].operatorNicks[dataToCount[i].operatorNicks.length - 1])
    }
    let agentsList = allRecordsAgent.filter((item, i, arr) => arr.indexOf(item) === i);
    addCountent = "";
    for (let i = 0; i < agentsList.length; i++) {
        if (agentsList[i] !== undefined) {
            let regexAgentName = new RegExp(agentsList[i], "g");
            let agentsCount = allRecordsAgent.join(" ").match(regexAgentName).length;
            newAgents.push({ [agentsList[i]]: agentsCount });
        }
    }
    cleanRecordsCountObj.agentsCount = Object.assign({}, newAgents);
    // count unique agents end

    return cleanRecordsCountObj;
}
// CREATE FULL COUNTS LIST FUNCTION END

// BUILD FILTERING OPTIONS FUNCTION START
async function buildFilteringSection() {
    let filterControlContainer = getE(".data-filtering-container");
    let badgeCountsObj = await recordsCounter(allRecords);

    // get&build PROJECTS list START
    let addCountent = "";
    for (let i = 0; i < Object.keys(badgeCountsObj.projectsCount).length; i++) {
        let optionLabel = Object.keys(badgeCountsObj.projectsCount[i]).toString(),
            optionCount = Object.values(badgeCountsObj.projectsCount[i]).toString();
        addCountent += `
        <label for="isShow${optionLabel}" >
        <input type="checkbox" name="isShow${optionLabel}" 
        id="isShow${optionLabel}" value="${optionLabel}">
        <div class="filter-label-text-box">${optionLabel}
        <span id="_${optionLabel}Badge" class="countBadge">${optionCount}</span>
        </div>
        </label>`;
    }
    filterControlContainer.innerHTML = `
        <fieldset class="projectsList-fieldset">
        <legend>Проєкти:</legend>
        <label for="IsShowAllProjects">
        <input type="checkbox" name="showProjects" id="IsShowAllProjects" value="allProjectsList">
        <div class="filter-label-text-box">All</div>
        </label>
        ${addCountent}
        </fieldset>`;
    // get&build PROJECTS list END

    // get&build CONVERSATION TYPES list START
    addCountent = "";
    for (let i = 0; i < Object.keys(badgeCountsObj.convTypesCount).length; i++) {
        let optionLabel = Object.keys(badgeCountsObj.convTypesCount[i]).toString(),
            optionCount = Object.values(badgeCountsObj.convTypesCount[i]).toString();
        addCountent += `
        <label for="isShow${optionLabel}" >
        <input type="checkbox" name="isShow${optionLabel}" 
        id="isShow${optionLabel}" value="${optionLabel}">
        <div class="filter-label-text-box">${(optionLabel === "chat") ? "Чати" : "Тікети"}
        <span id="_${optionLabel}Badge" class="countBadge">${optionCount}</span>
        </div>
        </label>`;
    }
    filterControlContainer.innerHTML += `
        <fieldset class="conversationTypesList-fieldset">
        <legend>Типи звернень:</legend>
        <label for="IsShowAllConversationTypes">
        <input type="checkbox" name="IsShowAllConversationTypes" id="IsShowAllConversationTypes" value="allConversationTypes">
        <div class="filter-label-text-box">All</div>
        </label>
        ${addCountent}
        </fieldset>`;
    // get&build CONVERSATION TYPES list END

    // get&build CATEGORIES list START
    addCountent = "";
    for (let i = 0; i < Object.keys(badgeCountsObj.categoriesCount).length; i++) {
        let optionLabel = Object.keys(badgeCountsObj.categoriesCount[i]).toString(),
            optionCount = Object.values(badgeCountsObj.categoriesCount[i]).toString();

        let optionValue;
        for (const key in catgoryRuNames) {
            if (optionLabel === catgoryRuNames[key]) {
                optionValue = optionLabel;
                optionLabel = key;
            }
        }
        addCountent += `
        <label for="isShow${optionLabel}" >
        <input type="checkbox" name="isShow${optionLabel}" 
        id="isShow${optionLabel}" value="${optionValue}">
        <div class="filter-label-text-box">
        ${(optionValue.length > 23) ? optionValue.substring(0, 22) : optionValue}
        <span id="_${optionLabel}Badge" class="countBadge ${(optionValue.length > 23) ? "badgeShadow" : ""}">${optionCount}</span>
        </div>
        </label>`;
    }
    filterControlContainer.innerHTML += `
        <fieldset class="categoriesList-fieldset">
        <legend>Категорії:</legend>
        <label for="IsShowAllCategories">
        <input type="checkbox" name="IsShowAllCategories" id="IsShowAllCategories" value="allCategories">
        <div class="filter-label-text-box">All</div>
        </label>
        ${addCountent}
        </fieldset>`;
    // get&build CATEGORIES list END

    // get&build AGENTS list START
    addCountent = "";
    for (let i = 0; i < Object.keys(badgeCountsObj.agentsCount).length; i++) {
        let optionLabel = Object.keys(badgeCountsObj.agentsCount[i]).toString(),
            optionCount = Object.values(badgeCountsObj.agentsCount[i]).toString();
        addCountent += `
        <label for="isShow${optionLabel}" >
        <input type="checkbox" name="isShow${optionLabel}" 
        id="isShow${optionLabel}" value="${optionLabel}">
        <div class="filter-label-text-box">${(optionLabel === "noAgent") ? "Немає відповідального" : optionLabel}
        <span id="_${optionLabel}Badge" class="countBadge">${optionCount}</span>
        </div>
        </label>`;
    }
    filterControlContainer.innerHTML += `
        <fieldset class="agentsList-fieldset">
        <legend>Менеджери:</legend>
        <label for="IsShowAllAgents">
        <input type="checkbox" name="IsShowAllAgents" id="IsShowAllAgents" value="allAgents">
        <div class="filter-label-text-box">All</div>
        </label>
        ${addCountent}
        </fieldset>`;
    // get&build AGENTS list END

    // build DATA CONTROL options START
    getE(".data-options-container").innerHTML =
        `<fieldset class="filter-control-fieldset">
        <input type="button" id="resetFilters"
        onclick="resetFilters()" value="Скинути">
        <input type="button" id="downloadCustomReport" 
        onclick="createReport(savedfilteredDataArr,'filteredData')" value="Звіт" disabled>
        <input type="button" id="showDataTable" 
        onclick="showDataTable()" value="Таблиця">
        <input type="search" id="searchInput">
        <input type="button" id="searchBtn" value="Пошук">
        </fieldset>`;
    // build DATA CONTROL options END

    await getInfo();
    buildFilters();
    renderResults(true);
    await buildReportSection();
}
// BUILD FILTERING OPTIONS FUNCTION END

// BUILD FILTERS FUNCTION START
let buildedFilter = {};
async function buildFilters() {
    // build PROJECTS filter START
    let projectsListSect = getE('.projectsList-fieldset');
    let allProjectsCheckBox = getE('#IsShowAllProjects');

    allProjectsCheckBox.checked = true;
    let firstSelectedArr = []
    if (allProjectsCheckBox.checked) {
        for (let i = 2; i < projectsListSect.children.length; i++) {
            firstSelectedArr.push(projectsListSect.children[i].firstElementChild.value)
        }
        buildedFilter.projectsFilter = firstSelectedArr;
    }

    projectsListSect.onchange = (e) => {
        let selectedProjectsArr = [];
        if (allProjectsCheckBox.checked && firstSelectedArr.length > 0 ||
            !allProjectsCheckBox.checked && firstSelectedArr.length > 0) {
            allProjectsCheckBox.checked = false;
            for (let i = 2; i < projectsListSect.children.length; i++) {
                if (projectsListSect.children[i].firstElementChild.checked) {
                    selectedProjectsArr.push(projectsListSect.children[i].firstElementChild.value)
                }
            }
            let count = 0;
            for (let i = 2; i < projectsListSect.children.length; i++) {
                if (!projectsListSect.children[i].firstElementChild.checked) count++;
                if (count === projectsListSect.children.length - 2) allProjectsCheckBox.checked = true;
            }
            buildedFilter.projectsFilter = selectedProjectsArr;
        }
        if (allProjectsCheckBox.checked) {
            for (let i = 2; i < projectsListSect.children.length; i++) {
                selectedProjectsArr.push(projectsListSect.children[i].firstElementChild.value)
            }
            buildedFilter.projectsFilter = selectedProjectsArr;
        }
        filterResults(buildedFilter);
        recordsCounter(filteredDataArr);
    }
    // build PROJECTS filter END

    // build CONVERSATION TYPES filter START
    let convTypesSect = getE('.conversationTypesList-fieldset');
    let allConvTypesCheckBox = getE('#IsShowAllConversationTypes');

    allConvTypesCheckBox.checked = true;
    firstSelectedArr = []
    if (allConvTypesCheckBox.checked) {
        for (let i = 2; i < convTypesSect.children.length; i++) {
            firstSelectedArr.push(convTypesSect.children[i].firstElementChild.value)
        }
        buildedFilter.convTypesFilter = firstSelectedArr;
    }

    convTypesSect.onchange = (e) => {
        let selectedConvTypesArr = [];
        if (allConvTypesCheckBox.checked && firstSelectedArr.length > 0 ||
            !allConvTypesCheckBox.checked && firstSelectedArr.length > 0) {
            allConvTypesCheckBox.checked = false;
            for (let i = 2; i < convTypesSect.children.length; i++) {
                if (convTypesSect.children[i].firstElementChild.checked) {
                    selectedConvTypesArr.push(convTypesSect.children[i].firstElementChild.value)
                }
            }
            let count = 0;
            for (let i = 2; i < convTypesSect.children.length; i++) {
                if (!convTypesSect.children[i].firstElementChild.checked) count++;
                if (count === convTypesSect.children.length - 2) allConvTypesCheckBox.checked = true;
            }
            buildedFilter.convTypesFilter = selectedConvTypesArr;
        }
        if (allConvTypesCheckBox.checked) {
            for (let i = 2; i < convTypesSect.children.length; i++) {
                selectedConvTypesArr.push(convTypesSect.children[i].firstElementChild.value)
            }
            buildedFilter.convTypesFilter = selectedConvTypesArr;
        }
        filterResults(buildedFilter);
        recordsCounter(filteredDataArr);
    }
    // build CONVERSATION TYPES filter END

    // build CATEGORIES filter START
    let categoriesListSect = getE('.categoriesList-fieldset');
    let allCategoriesCheckBox = getE('#IsShowAllCategories');

    allCategoriesCheckBox.checked = true;
    firstSelectedArr = []
    if (allCategoriesCheckBox.checked) {
        for (let i = 2; i < categoriesListSect.children.length; i++) {
            firstSelectedArr.push(categoriesListSect.children[i].firstElementChild.value)
        }
        buildedFilter.categoriesFilter = firstSelectedArr;
    }

    categoriesListSect.onchange = (e) => {
        let selectedCategoriesArr = [];
        if (allCategoriesCheckBox.checked && firstSelectedArr.length > 0 ||
            !allCategoriesCheckBox.checked && firstSelectedArr.length > 0) {
            allCategoriesCheckBox.checked = false;
            for (let i = 2; i < categoriesListSect.children.length; i++) {
                if (categoriesListSect.children[i].firstElementChild.checked) {
                    selectedCategoriesArr.push(categoriesListSect.children[i].firstElementChild.value);
                }
            }
            let count = 0;
            for (let i = 2; i < categoriesListSect.children.length; i++) {
                if (!categoriesListSect.children[i].firstElementChild.checked) count++;
                if (count === categoriesListSect.children.length - 2) allCategoriesCheckBox.checked = true;
            }
            buildedFilter.categoriesFilter = selectedCategoriesArr;
        }
        if (allCategoriesCheckBox.checked) {
            for (let i = 2; i < categoriesListSect.children.length; i++) {
                selectedCategoriesArr.push(categoriesListSect.children[i].firstElementChild.value)
            }
            buildedFilter.categoriesFilter = selectedCategoriesArr;
        }
        filterResults(buildedFilter);
        recordsCounter(filteredDataArr);
    }
    // build CATEGORIES filter END

    // build AGENTS filter START
    let agentsListSect = getE('.agentsList-fieldset');
    let allAgentsCheckBox = getE('#IsShowAllAgents');

    allAgentsCheckBox.checked = true;
    firstSelectedArr = []
    if (allAgentsCheckBox.checked) {
        for (let i = 2; i < agentsListSect.children.length; i++) {
            firstSelectedArr.push(agentsListSect.children[i].firstElementChild.value)
        }
        buildedFilter.agentsFilter = firstSelectedArr;
    }
    agentsListSect.onchange = (e) => {
        let selectedAgentsArr = [];
        if (allAgentsCheckBox.checked && firstSelectedArr.length > 0 ||
            !allAgentsCheckBox.checked && firstSelectedArr.length > 0) {
            allAgentsCheckBox.checked = false;
            for (let i = 2; i < agentsListSect.children.length; i++) {
                if (agentsListSect.children[i].firstElementChild.checked) {
                    selectedAgentsArr.push(agentsListSect.children[i].firstElementChild.value)
                }
            }
            let count = 0;
            for (let i = 2; i < agentsListSect.children.length; i++) {
                if (!agentsListSect.children[i].firstElementChild.checked) count++;
                if (count === agentsListSect.children.length - 2) allAgentsCheckBox.checked = true;
            }
            buildedFilter.agentsFilter = selectedAgentsArr;
        }
        if (allAgentsCheckBox.checked) {
            for (let i = 2; i < agentsListSect.children.length; i++) {
                selectedAgentsArr.push(agentsListSect.children[i].firstElementChild.value)
            }
            buildedFilter.agentsFilter = selectedAgentsArr;
        }
        filterResults(buildedFilter);
        recordsCounter(filteredDataArr);
    }
    // build AGENTS filter END
}
// BUILD FILTERS FUNCTION END

// FILTER RESULTS FUNCTION START
let filteredDataArr = [], savedfilteredDataArr = [];
async function filterResults(buildedFilter) {
    // filtering by PROJECT NAME START
    if (buildedFilter.projectsFilter !== undefined && buildedFilter.projectsFilter.length !== 0) {
        let filrteringArr = [];
        if (filteredDataArr.length !== 0) {
            filrteringArr = filteredDataArr;
            filteredDataArr = [];
        }
        else if (filteredDataArr.length === 0) {
            filrteringArr = allRecords;
        }
        for (let i = 0; i < filrteringArr.length; i++) {
            for (let a = 0; a < buildedFilter.projectsFilter.length; a++) {
                if (filrteringArr[i].projectName === buildedFilter.projectsFilter[a]) {
                    filteredDataArr.push(filrteringArr[i]);
                }
            }
        }
    }
    // filtering by PROJECT NAME END

    // filtering by CONVERSATION TYPE START
    if (buildedFilter.convTypesFilter !== undefined && buildedFilter.convTypesFilter.length !== 0) {
        let filrteringArr = [];
        if (filteredDataArr.length !== 0) {
            filrteringArr = filteredDataArr;
            filteredDataArr = [];
        }
        else if (filteredDataArr.length === 0) {
            filrteringArr = allRecords;
        }
        for (let i = 0; i < filrteringArr.length; i++) {
            for (let a = 0; a < buildedFilter.convTypesFilter.length; a++) {
                if (filrteringArr[i].conversationType === buildedFilter.convTypesFilter[a]) {
                    filteredDataArr.push(filrteringArr[i]);
                }
            }
        }
    }
    // filtering by CONVERSATION TYPE END

    // filtering by CATEGORY START
    if (buildedFilter.categoriesFilter !== undefined && buildedFilter.categoriesFilter.length !== 0) {
        let filrteringArr = [];
        if (filteredDataArr.length !== 0) {
            filrteringArr = filteredDataArr;
            filteredDataArr = [];
        }
        else if (filteredDataArr.length === 0) {
            filrteringArr = allRecords;
        }
        for (let i = 0; i < filrteringArr.length; i++) {
            for (let a = 0; a < buildedFilter.categoriesFilter.length; a++) {
                if (filrteringArr[i].conversationCategory === buildedFilter.categoriesFilter[a]) {
                    filteredDataArr.push(filrteringArr[i]);
                }
            }
        }
    }
    // filtering by CATEGORY END

    // filtering by AGENT NAME START
    if (buildedFilter.agentsFilter !== undefined && buildedFilter.agentsFilter.length !== 0) {
        let filrteringArr = [];
        if (filteredDataArr.length !== 0) {
            filrteringArr = filteredDataArr;
            filteredDataArr = [];
        }
        else if (filteredDataArr.length === 0) {
            filrteringArr = allRecords;
        }
        for (let i = 0; i < filrteringArr.length; i++) {
            for (let a = 0; a < buildedFilter.agentsFilter.length; a++) {
                if (filrteringArr[i].operatorNicks[filrteringArr[i].operatorNicks.length - 1] === buildedFilter.agentsFilter[a]) {
                    filteredDataArr.push(filrteringArr[i]);
                }
            }
        }

    }
    // filtering by AGENT NAME END

    await renderResults(false);
    savedfilteredDataArr = filteredDataArr;
    await recordsCounter(filteredDataArr);
    filteredDataArr = [];
}
// FILTER RESULTS FUNCTION END

// UPDATE ALL COUNTS ON PAGE FUNCTION START
const dataFilteringContainer = getE(".data-filtering-container");
dataFilteringContainer.onchange = async (e) => {
    let badgeCountsObj = await recordsCounter(savedfilteredDataArr);
    let countObjKeys = [];
    for (const key in badgeCountsObj) countObjKeys.push(key);

    let countWasSetArr = [];
    for (let objKey = 0; objKey < countObjKeys.length; objKey++) {
        for (let i = 0; i < Object.keys(badgeCountsObj[countObjKeys[objKey]]).length; i++) {
            let optionLabel = Object.keys(badgeCountsObj[countObjKeys[objKey]][i]).toString(),
                optionCount = Object.values(badgeCountsObj[countObjKeys[objKey]][i]).toString();
            if (/[А-Яа-я]/.test(optionLabel)) {
                for (const key in catgoryRuNames) {
                    if (optionLabel === catgoryRuNames[key]) optionLabel = key;
                }
            }
            let setNewBadgeCount = getE(`#isShow${optionLabel}`).nextElementSibling.firstElementChild;
            setNewBadgeCount.innerHTML = optionCount;
            // setNewBadgeCount.style.opacity = 1;
            // setNewBadgeCount.classList.remove("zeroRecords");
            countWasSetArr.push(setNewBadgeCount.id);
        }
    }

    let allCountBadgeIds = [];
    for (let sectNum = 0; sectNum < dataFilteringContainer.children.length; sectNum++) {
        let currSection = dataFilteringContainer.children[sectNum];
        for (let elem = 2; elem < currSection.children.length; elem++) {
            let checkingElem = currSection.children[elem].firstElementChild.nextElementSibling.firstElementChild;
            allCountBadgeIds.push(checkingElem.id)
        }
    }

    setZerosArr = allCountBadgeIds.filter(function (n) { return !this.has(n) }, new Set(countWasSetArr));
    for (let zeroElem = 0; zeroElem < setZerosArr.length; zeroElem++) {
        getE(`#${setZerosArr[zeroElem]}`).innerHTML = 0;
        // getE(`#${setZerosArr[zeroElem]}`).style.opacity = 0;
        // getE(`#${setZerosArr[zeroElem]}`).classList.add("zeroRecords");
    }

    if (getE('#IsShowAllProjects').checked &&
        getE('#IsShowAllConversationTypes').checked &&
        getE('#IsShowAllCategories').checked &&
        getE('#IsShowAllAgents').checked) {
        getE("#downloadCustomReport").disabled = true;
    }
    else {
        getE("#downloadCustomReport").disabled = false;
    }
}
// UPDATE ALL COUNTS ON PAGE FUNCTION END

// BUILD OBJECT FOR TABLE DISPLAY FUNCTION START
let tableDataObj = {};
async function buildObjForTableDisplay(recordsToRenderArr) {
    let workArr = [];

    // build projects START
    let projectKeyName = [];
    for (const key in cleanRecordsCountObj.projectsCount) {
        let newKeyName = Object.keys(cleanRecordsCountObj.projectsCount[key]);
        workArr.push({ [newKeyName]: '' })
        projectKeyName.push(newKeyName);
    }
    tableDataObj.projects = Object.assign({}, workArr);
    // build projects END

    // build conversation types START
    workArr = [];
    for (const projectKeyName in tableDataObj.projects) {
        for (const key in cleanRecordsCountObj.convTypesCount) {
            let newKeyName = Object.keys(cleanRecordsCountObj.convTypesCount[key]);
            workArr.push({ [newKeyName]: '' })
        }
        let key = Object.keys(tableDataObj.projects[projectKeyName]).toString();
        tableDataObj.projects[projectKeyName][key] = Object.assign({}, workArr);
        workArr = [];
    }
    // build conversation types START

    // build categories START
    let workArrChat = [], workArrTicket = [];
    for (const projectKeyIndex in tableDataObj.projects) {
        let keyProject = Object.keys(tableDataObj.projects[projectKeyIndex]).toString();
        for (let record = 0; record < recordsToRenderArr.length; record++) {
            a2 = recordsToRenderArr[record];
            if (recordsToRenderArr[record].projectName === keyProject) {
                for (const key in tableDataObj.projects[projectKeyIndex]) {
                    let projectObj = Object.values(tableDataObj.projects[projectKeyIndex][key]);
                    for (const keyConvTypeIndex in projectObj) {
                        let keyConvType = Object.keys(projectObj[keyConvTypeIndex]).toString();
                        if (recordsToRenderArr[record].conversationType === keyConvType && keyConvType === "chat") {
                            let newRecord = recordsToRenderArr[record].conversationCategory;
                            workArrChat.push(newRecord);
                        }
                        else if (recordsToRenderArr[record].conversationType === keyConvType && keyConvType === "ticket") {
                            let newRecord = recordsToRenderArr[record].conversationCategory;
                            workArrTicket.push(newRecord);
                        }
                    }
                }
            }
        }
        for (const key in tableDataObj.projects[projectKeyIndex]) {
            for (const convTypeIndex in tableDataObj.projects[projectKeyIndex][key]) {
                let key1 = Object.keys(tableDataObj.projects[projectKeyIndex][key][convTypeIndex]).toString();
                if (key1 === "chat") {
                    tableDataObj.projects[projectKeyIndex][key][convTypeIndex][key1] = workArrChat;
                    workArrChat = [];
                }
                if (key1 === "ticket") {
                    tableDataObj.projects[projectKeyIndex][key][convTypeIndex][key1] = workArrTicket;
                    workArrTicket = [];
                }
            }
        }
    }
    // build categories START
}
// BUILD OBJECT FOR TABLE DISPLAY FUNCTION END

// SORT AND CLEAN CHATS FUNCTION START
async function cleanChatRecords() {
    // find concat positions START
    let fRowArr = dataByRecordsChats[0].substring(1, dataByRecordsChats[0].length - 1).split('","');
    let operatorNickStart,
        operatorIdStart,
        operatorTimeZoneStart,
        preChatEmailStart,
        tag1Start,
        firstResponseTimeStart;
    for (let i = 0; i < fRowArr.length; i++) {
        if (fRowArr[i] === "operator 1 nick") operatorNickStart = i;
        if (fRowArr[i] === "operator 1 id") operatorIdStart = i;
        if (fRowArr[i] === "operator 1 time zone") operatorTimeZoneStart = i;
        if (fRowArr[i] === "pre chat: E-mail:") preChatEmailStart = i;
        if (fRowArr[i] === "tag 1") tag1Start = i;
        if (fRowArr[i] === "first response time") firstResponseTimeStart = i;
    }
    // find concat positions END

    for (let record = 1; record < dataByRecordsChats.length - 1; record++) {
        let dataByCells = dataByRecordsChats[record].substring(1, dataByRecordsChats[record].length - 1).split('","');
        if (dataByCells[13] === "7Bit Support | login | 1+ dep" ||
            dataByCells[13] === "7bit Support Deparment" ||
            dataByCells[13] === "7bit Support Deparment | login | nodep" ||
            dataByCells[13] === "7bit Support Department | login | nodep" ||
            dataByCells[13] === "Katsubet Support | login | 1+ dep" ||
            dataByCells[13] === "Katsubet Support Department" ||
            dataByCells[13] === "Katsubet Support Department | login | nodep" ||
            dataByCells[13] === "Mirax Support | login | 1+ dep" ||
            dataByCells[13] === "Mirax Support Department" ||
            dataByCells[13] === "Mirax Support Department | login | nodep") {

            // put wide data to arrays START
            let operatorAccounts = [];
            for (let i = operatorNickStart; i < operatorIdStart; i++) {
                if (dataByCells[i] !== "") operatorAccounts.push(dataByCells[i]);
            }
            let operatorIds = [];
            for (let i = operatorIdStart; i < operatorTimeZoneStart; i++) {
                if (dataByCells[i] !== "") operatorIds.push(dataByCells[i]);
            }
            let operatorTimeZones = [];
            for (let i = operatorTimeZoneStart; i < preChatEmailStart; i++) {
                if (dataByCells[i] !== "") operatorTimeZones.push(dataByCells[i]);
            }
            let tags = [];
            for (let i = tag1Start; i < firstResponseTimeStart; i++) {
                if (dataByCells[i] !== "") tags.push(dataByCells[i]);
            }
            let operatorNicks = [];
            for (let tag = 0; tag < tags.length; tag++) {
                if (/7\s*-/.test(tags[tag])) {
                    let setTag = tags[tag].substring((tags[tag].match(/[a-zA-Z]/).index), tags[tag].length)
                    if (tags[tag].includes("/")) setTag = setTag.substring(0, setTag.indexOf('/'));
                    operatorNicks.push(setTag);
                }
            }

            // put wide data to arrays END

            // leave only EMPTY, DUPS and other cases START 
            let checkChat = false;
            if (/@/.test(dataByCells[11])) {
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i].includes('5')) {
                        checkChat = true;
                        break;
                    }
                    if (!tags[i].includes('5') && i === tags.length - 1) {
                        let noReplyCheck1 = false, spamCheck2 = false;
                        for (let a = 0; a < tags.length; a++) {
                            if (tags[a] !== "1-NO REPLY") noReplyCheck1 = true;
                            else if (tags[a] === "1-NO REPLY") {
                                noReplyCheck1 = false;
                                break;
                            }
                        }
                        for (let a = 0; a < tags.length; a++) {
                            if (tags[a] !== "1-SPAM") spamCheck2 = true;
                            else if (tags[a] === "1-SPAM") {
                                spamCheck2 = false;
                                break;
                            }
                        }
                        if (noReplyCheck1 && spamCheck2) {
                            checkChat = true;
                            break;
                        }
                    }
                }
            }
            // leave only EMPTY, DUPS and other cases END 

            if (checkChat) {
                // check if CATEGORY doubled START
                let dupsCheck = 0;
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i].includes('5')) dupsCheck++;
                }
                if (dupsCheck > 1) {
                    let checkRecord = {
                        id: dataByCells[0],
                        sourse: "chat",
                        problemLink: "https://my.livechatinc.com/archives/" + dataByCells[0],
                        problemDesc: "дубльована мітка категорії/й",
                        problemType: "CATDUPS",
                        tags: tags,
                        rmvPosChats: recordsChats.length === 0 ? 0 : recordsChats.length,
                        rmvPosAllList: allRecords.length === 0 ? 0 : allRecords.length,
                    }
                    checkList.push(checkRecord);
                }
                // check if CATEGORY doubled END

                // check if NO REPLY and/or SPAM with CATEGORY START
                let noRepAndCATcheck = false;
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i].includes("1-NO REPLY") || tags[i].includes("1-SPAM")) {
                        for (let a = 0; a < tags.length; a++) {
                            if (tags[a].includes('5')) {
                                noRepAndCATcheck = true;
                            }
                        }
                    }
                }
                if (noRepAndCATcheck) {
                    let checkRecord = {
                        id: dataByCells[0],
                        sourse: "chat",
                        problemLink: "https://my.livechatinc.com/archives/" + dataByCells[0],
                        problemDesc: "мітка (SPAM та/або NO REPLY) разом з категорією",
                        problemType: "NOREPLYANDCAT",
                        tags: tags,
                        rmvPosChats: recordsChats.length === 0 ? 0 : recordsChats.length,
                        rmvPosAllList: allRecords.length === 0 ? 0 : allRecords.length,
                    }
                    checkList.push(checkRecord);
                }
                // check if NO REPLY and/or SPAM with CATEGORY END

                // mark record with proper PROJECT name START
                let projectName = "";
                if (dataByCells[13] === "7Bit Support | login | 1+ dep" ||
                    dataByCells[13] === "7bit Support Deparment" ||
                    dataByCells[13] === "7bit Support Deparment | login | nodep" ||
                    dataByCells[13] === "7bit Support Department | login | nodep") {
                    projectName = "7Bit"
                }
                else if (dataByCells[13] === "Katsubet Support | login | 1+ dep" ||
                    dataByCells[13] === "Katsubet Support Department" ||
                    dataByCells[13] === "Katsubet Support Department | login | nodep") {
                    projectName = "KatsuBet"
                }
                else if (dataByCells[13] === "Mirax Support | login | 1+ dep" ||
                    dataByCells[13] === "Mirax Support Department" ||
                    dataByCells[13] === "Mirax Support Department | login | nodep") {
                    projectName = "Mirax"
                }
                // mark record with proper PROJECT name END

                // find record CATEGORY START
                let category;
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i].includes(5)) {
                        switch (tags[i]) {
                            case "5-Акции и бонусы":
                                category = "Акции и бонусы";
                                break;
                            case "5-Безопасность":
                                category = "Безопасность";
                                break;
                            case "5-Верификация аккаунта":
                                category = "Верификация аккаунта";
                                break;
                            case "5-Вопросы по сайту":
                                category = "Вопросы по сайту";
                                break;
                            case "5-Восстановление доступа":
                                category = "Восстановление доступа";
                                break;
                            case "5-Другие тикеты":
                                category = "Другие тикеты";
                                break;
                            case "5-Закрытие аккаунта":
                                category = "Закрытие аккаунта";
                                break;
                            case "5-Изменения аккаунта":
                                category = "Изменения аккаунта";
                                break;
                            case "5-Макс бет (игры/слоты)":
                                category = "Макс бет (игры/слоты)";
                                break;
                            case "5-Непройденный депозит":
                                category = "Непройденный депозит";
                                break;
                            case "5-Партнерство":
                                category = "Партнерство";
                                break;
                            case "5-Проблемы по сайту":
                                category = "Проблемы по сайту";
                                break;
                            case "5-Проблемы с играми":
                                category = "Проблемы с играми";
                                break;
                            case "5-Рассылка":
                                category = "Рассылка";
                                break;
                            case "5-Регистрация":
                                category = "Регистрация";
                                break;
                            case "5-Тест":
                                category = "Тест";
                                break;
                            case "5-Технические проблемы(кроме бонусов)":
                                category = "Технические проблемы(кроме бонусов)";
                                break;
                            case "5-Финансовые операции":
                                category = "Финансовые операции";
                                break;
                        }
                    }
                }
                // find record CATEGORY END

                let recordObj = {
                    createdAt: new Date(dataByCells[1]).toLocaleString("uk-UA").replace(',', ""), // conversation start date&time
                    conferenceId: dataByCells[0], // conversation ID
                    projectName: projectName, // project name 
                    conversationType: "chat",
                    conversationLink: "https://my.livechatinc.com/archives/" + dataByCells[0],
                    conversationCategory: (category !== undefined) ? category : "Без категорії", // conversation category
                    conversationTags: tags, // converstaion tags
                    operatorNicks: (operatorNicks.length === 0) ? ["noAgent"] : operatorNicks, // operatorNicks
                    customerId: dataByCells[7], // customer ID (for chats it has unique ID)
                    customerEmail: dataByCells[10], // customer email
                    specialFields: {
                        converstionTimings: {
                            conversationDurationSec: dataByCells[5], // conversation duration in seconds
                            queueDurationSec: dataByCells[6], // conversation queue (before agent receive chat) duration in seconds
                            firstResponseTime: dataByCells[26], // first response time (seconds)
                            averageResponseTime: dataByCells[27], // average response time (seconds)
                            agentsChattingDuration: dataByCells[28], // agents chating duration (seconds)
                        },
                        chatStartDate: dataByCells[2], // chatStartDate ***
                        chatStartUrl: dataByCells[3], // chatStartUrl ***
                        referrer: dataByCells[4], // referrer ***
                        visitorNick: dataByCells[8], // customer Name ***
                        visitorIp: dataByCells[9], // visitorIp ***
                        lastAccountId: dataByCells[11], // lastAccountId ***
                        groupNum: dataByCells[12], // groupNum ***
                        conversationCustomerRating: { rateMark: dataByCells[14], rateComment: dataByCells[15] }, // conversation customer rating ***
                        operatorIds: operatorIds, // operatorIds ***
                        operatorTimeZones: operatorTimeZones, // operatorTimeZones ***
                        preChatEmail: dataByCells[19], // preChatEmail ***
                        autoInviteOption: { autoInviteUrl: dataByCells[20], autoInviteAction: dataByCells[21] }, // conversation auto invite option ***
                        conversationGoal: { goalActionName: dataByCells[22], goalDoneBy: dataByCells[23], goalDoneDate: dataByCells[24], }, // conversation goal ***
                        visitorUserAgent: dataByCells[29], // visitorUserAgent ***
                        groupStatusAtStart: dataByCells[30], // groupStatusAtStart ***
                        visitorCountryCode: dataByCells[31], // visitorCountryCode ***
                        operatorAccounts: operatorAccounts, // manager Account
                    },
                }
                // check if ticket without category START
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i].includes('5')) break;
                    if (!tags[i].includes('5')) {
                        if (i === tags.length - 1) {
                            let checkRecord = {
                                id: dataByCells[0],
                                sourse: "chat",
                                problemLink: "https://my.livechatinc.com/archives/" + dataByCells[0],
                                problemDesc: "немає мітки категорії",
                                problemType: "EMPTY",
                                tags: tags,
                                rmvPosChats: recordsChats.length === 0 ? 0 : recordsChats.length,
                                rmvPosAllList: allRecords.length === 0 ? 0 : allRecords.length,
                            }
                            checkList.push(checkRecord);
                        }
                    }
                }
                // check if ticket without category END

                recordsChats.push(recordObj);
                allRecords.push(recordObj);
            }
        }
    }
}
// SORT AND CLEAN TICKETS FUNCTION START
async function cleanTicketRecords() {
    for (let record = 1; record < dataByRecordsTickets.length - 1; record++) {
        let dataByCells = dataByRecordsTickets[record].substring(1, dataByRecordsTickets[record].length - 1).split('","');

        if (dataByCells[9] === "Менеджеры 7bit" ||
            dataByCells[9] === "Менеджеры WIN7bit" ||
            dataByCells[9] === "Менеджеры Кatsubet" ||
            dataByCells[9] === " Менеджеры Mirax" ||
            dataByCells[9] === "Менеджеры Mirax") {

            let operatorNicks = [];
            let operatorAccountName = [];
            if (dataByCells[10] !== "") operatorAccountName.push(dataByCells[10]);

            if (
                dataByCells[12].length !== 0 && dataByCells[12].includes("4") && dataByCells[12].includes("1-NO REPLY") ||
                dataByCells[12].length !== 0 && dataByCells[12].includes("4") && dataByCells[12].includes("1-SPAM") ||
                dataByCells[12].length !== 0 && !dataByCells[12].includes("1-NO REPLY") && !dataByCells[12].includes("1-SPAM")
            ) {
                let tags = dataByCells[12].split(";");
                for (let tag = 0; tag < tags.length; tag++) {
                    if (/6\s*-/.test(tags[tag]) || /7\s*-/.test(tags[tag])) {
                        let setTag = tags[tag].substring((tags[tag].match(/[a-zA-Z]/).index), tags[tag].length)
                        if (tags[tag].includes("/")) setTag = setTag.substring(0, setTag.indexOf('/'));
                        operatorNicks.push(setTag);
                    }
                }
                // check if CATEGORY doubled START
                let count = 0;
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i].includes('4')) {
                        count++;
                    }
                }
                if (count > 1) {
                    let checkRecord = {
                        id: dataByCells[3],
                        sourse: "ticket",
                        problemLink: "https://app.helpdesk.com/tickets/" + dataByCells[3],
                        problemDesc: "дубльована мітка категорії/й",
                        problemType: "CATDUPS",
                        tags: tags,
                        rmvPosTickets: recordsTickets.length === 0 ? 0 : recordsTickets.length,
                        rmvPosAllList: allRecords.length === 0 ? 0 : allRecords.length,
                    }
                    checkList.push(checkRecord);
                }
                else if (count <= 1) {
                    count = 0;
                }
                // check if CATEGORY doubled END

                // check if NO REPLY and/or SPAM with CATEGORY START
                let noRepAndCATcheck = false;
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i].includes("1-NO REPLY") || tags[i].includes("1-SPAM")) {
                        for (let a = 0; a < tags.length; a++) {
                            if (tags[a].includes('4')) {
                                noRepAndCATcheck = true;
                            }
                        }
                    }
                }
                if (noRepAndCATcheck) {
                    let checkRecord = {
                        id: dataByCells[3],
                        sourse: "ticket",
                        problemLink: "https://app.helpdesk.com/tickets/" + dataByCells[3],
                        problemDesc: "мітка (SPAM та/або NO REPLY) разом з категорією",
                        problemType: "NOREPLYANDCAT",
                        tags: tags,
                        rmvPosTickets: recordsTickets.length === 0 ? 0 : recordsTickets.length,
                        rmvPosAllList: allRecords.length === 0 ? 0 : allRecords.length,
                    }
                    checkList.push(checkRecord);
                }
                // check if NO REPLY and/or SPAM with CATEGORY END

                // mark record with proper PROJECT name START
                if (dataByCells[9] === "Менеджеры 7bit" ||
                    dataByCells[9] === "Менеджеры WIN7bit" ||
                    dataByCells[9] === "Менеджеры Кatsubet" ||
                    dataByCells[9] === " Менеджеры Mirax" ||
                    dataByCells[9] === "Менеджеры Mirax") {
                    let projectName = "";
                    if (dataByCells[9] === "Менеджеры 7bit" || dataByCells[9] === "Менеджеры WIN7bit") {
                        projectName = "7Bit"
                    }
                    else if (dataByCells[9] === "Менеджеры Кatsubet") {
                        projectName = "KatsuBet"
                    }
                    else if (
                        dataByCells[9] === " Менеджеры Mirax" || dataByCells[9] === "Менеджеры Mirax") {
                        projectName = "Mirax"
                    }
                    // mark record with proper PROJECT name END

                    // find record CATEGORY START
                    let category;
                    for (let i = 0; i < tags.length; i++) {
                        if (tags[i].includes('4')) {
                            switch (tags[i]) {
                                case "4-Акции и бонусы":
                                    category = "Акции и бонусы";
                                    break;
                                case "4-Безопасность":
                                    category = "Безопасность";
                                    break;
                                case "4-Верификация аккаунта":
                                    category = "Верификация аккаунта";
                                    break;
                                case "4-Вопросы по сайту":
                                    category = "Вопросы по сайту";
                                    break;
                                case "4-Восстановление доступа":
                                    category = "Восстановление доступа";
                                    break;
                                case "4-Другие тикеты":
                                    category = "Другие тикеты";
                                    break;
                                case "4-Закрытие аккаунта":
                                    category = "Закрытие аккаунта";
                                    break;
                                case "4-Изменения аккаунта":
                                    category = "Изменения аккаунта";
                                    break;
                                case "4-Макс бет (игры/слоты)":
                                    category = "Макс бет (игры/слоты)";
                                    break;
                                case "4-Непройденный депозит":
                                    category = "Непройденный депозит";
                                    break;
                                case "4-Партнерство":
                                    category = "Партнерство";
                                    break;
                                case "4-Проблемы по сайту":
                                    category = "Проблемы по сайту";
                                    break;
                                case "4-Проблемы с играми":
                                    category = "Проблемы с играми";
                                    break;
                                case "4-Рассылка":
                                    category = "Рассылка";
                                    break;
                                case "4-Регистрация":
                                    category = "Регистрация";
                                    break;
                                case "4-Тест":
                                    category = "Тест";
                                    break;
                                case "4-Технические проблемы(кроме бонусов)":
                                    category = "Технические проблемы(кроме бонусов)";
                                    break;
                                case "4-Финансовые операции":
                                    category = "Финансовые операции";
                                    break;
                            }
                        }
                    }
                    // find record CATEGORY END

                    let record = {
                        createdAt: new Date(dataByCells[0]).toLocaleString("uk-UA").replace(',', ""), // conversation start date&time
                        conferenceId: dataByCells[3], // conversation ID
                        projectName: projectName, // project name 
                        conversationType: "ticket",
                        conversationLink: "https://app.helpdesk.com/tickets/" + dataByCells[3],
                        conversationCategory: (category !== undefined) ? category : "Без категорії", // conversation category
                        conversationTags: tags, // converstaion tags
                        operatorNicks: (operatorNicks.length === 0) ? ["noAgent"] : operatorNicks, // operatorNicks
                        customerId: dataByCells[5], // customer ID (for chats it has unique ID)
                        customerEmail: dataByCells[5], // customer email
                        specialFields: {
                            operatorAccountName: operatorAccountName, // operator account name
                            requesterName: dataByCells[4], // customer Name ***
                            lastAccountId: dataByCells[11], // agent account Email (agentEmail) ***
                            conversationCustomerRating: { rateMark: dataByCells[14], rateComment: dataByCells[15] }, // conversation customer rating ***
                            updatedAtTicket: dataByCells[1], // ticket last update date&time ***
                            inboundOutboundTicket: dataByCells[2], // ticket source type ***
                            ticketStatus: dataByCells[6], // ticket status ***
                            ticketPriority: dataByCells[7], // ticket priority ***
                            ticketSubject: dataByCells[8], // ticket subject ***
                            publicMessages: dataByCells[13], // number of messages in the ticket
                            ticketInbox: dataByCells[16], // ticket inbox email ***
                            ticketFolder: dataByCells[17], // ticket folder ***
                        },
                    }

                    // check if ticket without category START
                    for (let i = 0; i < tags.length; i++) {
                        if (tags[i].includes('4')) break;
                        if (!tags[i].includes('4')) {
                            if (i === tags.length - 1) {
                                let checkRecord = {
                                    id: dataByCells[3],
                                    sourse: "ticket",
                                    problemLink: "https://app.helpdesk.com/tickets/" + dataByCells[3],
                                    problemDesc: "немає мітки категорії",
                                    problemType: "EMPTY",
                                    tags: tags,
                                    rmvPosTickets: recordsTickets.length === 0 ? 0 : recordsTickets.length,
                                    rmvPosAllList: allRecords.length === 0 ? 0 : allRecords.length,
                                }
                                checkList.push(checkRecord);
                            }
                        }
                    }
                    // check if ticket without category END
                    recordsTickets.push(record);
                    allRecords.push(record);
                }
            }
        }
    }
}
// SORT AND CLEAN TICKETS FUNCTION END

// SHOW AND BUILD DIALOG WINDOW FUNCTION START
let dialogContainer = getE('.dialogWindow-container'),
    dialogWindow = getE('.dialogWindow'),
    dialogHeader = getE('.dialogWindow-header'),
    dialogContent = getE('.dialogWindow-content');
async function showAndBuildDialog(checkList) {
    dialogContainer.classList.toggle('hide');
    dialogContent.innerHTML = `<p>У вибірці виявлено наступні елементи. Оберіть які з них очистити:</p>`;
    let cleanOptions = "", emptyCases = true, noReplyAndCat = true, catDups = true,
        countObj = { empty: 0, noReplyAndCat: 0, catDups: 0 };
    for (let record = 0; record < checkList.length; record++) {
        if (checkList[record].problemType === "EMPTY" && emptyCases) countObj.empty++;
        if (checkList[record].problemType === "NOREPLYANDCAT" && noReplyAndCat) countObj.noReplyAndCat++;
        if (checkList[record].problemType === "CATDUPS" && catDups) countObj.catDups++;
    }
    for (let i = 0; i < checkList.length; i++) {
        let titleSet = `Знайдено ${countObj.empty} звернень в яких відсутня мітка категорії.`;
        if (checkList[i].problemType === "EMPTY" && emptyCases) {
            cleanOptions += `<label for="emptyCases" title="${titleSet}">
            <input type="checkbox" name="emptyCases" id="emptyCases" checked>
            - без мітки категорії
            <span id="emptyBadge">(${countObj.empty})</span>
            </label>`;
            emptyCases = false;
        }
        titleSet = `Знайдено ${countObj.noReplyAndCat} звернень в яких є мітка категорії разом з NO REPLY та/або SPAM.`;
        if (checkList[i].problemType === "NOREPLYANDCAT" && noReplyAndCat) {
            cleanOptions += `<label for="noReplyAndCat" title="${titleSet}">
            <input type="checkbox" name="noReplyAndCat" id="noReplyAndCat" checked>
            - категорія та NO REPLY разом
            <span id="noReplyAndCatBadge"> (${countObj.noReplyAndCat})</span>
            </label>`;
            noReplyAndCat = false;
        }
        titleSet = `Знайдено ${countObj.noReplyAndCat} звернень в які мають більше ніж одну мітку категорії.`;
        if (checkList[i].problemType === "CATDUPS" && catDups) {
            cleanOptions += `<label for="catDups" title="${titleSet}">
            <input type="checkbox" name="catDups" id="catDups" checked>
            - категорія дубльована
            <span id="catDupsBadge">(${countObj.catDups})</span>
            </label>`;
            catDups = false;
        }
    }
    dialogContent.innerHTML += cleanOptions;
}
// SHOW AND BUILD DIALOG WINDOW FUNCTION END

// CHECK CLEANING OPTION FUNCTION START
let cleanChoice = [], cleaningCheck = getE('#cleaningCheck');
dialogWindow.onchange = () => {
    let dialogContent = getE('.dialogWindow-content'),
        btnClean = getE('#dialogClean'),
        btnIgnore = getE('#dialogIgnore'),
        emptyCheck = getE('#emptyCases'),
        emptyBadge = getE('#emptyBadge'),
        noReplyAndCatCheck = getE('#noReplyAndCat'),
        noReplyAndCatBadge = getE('#noReplyAndCatBadge'),
        catDupsCheck = getE('#catDups'),
        catDupsBadge = getE('#catDupsBadge');

    if (cleaningCheck.checked) {
        if (emptyCheck) {
            if (emptyCheck.checked) {
                if (!cleanChoice.includes("EMPTY")) cleanChoice.push("EMPTY");
                emptyBadge.style.display = "block";
            }
            emptyCheck.disabled = true;
        }
        if (noReplyAndCatCheck) {
            if (noReplyAndCatCheck.checked) {
                if (!cleanChoice.includes("NOREPLYANDCAT")) cleanChoice.push("NOREPLYANDCAT");
                noReplyAndCatBadge.style.display = "block";
            }
            noReplyAndCatCheck.disabled = true;
        }
        if (catDupsCheck) {
            if (catDupsCheck.checked) {
                if (!cleanChoice.includes("CATDUPS")) cleanChoice.push("CATDUPS");
                catDupsBadge.style.display = "block";
            }
            catDupsCheck.disabled = true;
        }
        btnClean.disabled = false;
        btnIgnore.disabled = false;
    }
    else if (!cleaningCheck.checked) {
        if (emptyCheck) {
            if (emptyCheck.checked) emptyBadge.style.display = "block";
            if (!emptyCheck.checked) {
                emptyBadge.style.display = "none";
                cleanChoice.splice(cleanChoice.indexOf("EMPTY"));
            }
            emptyCheck.disabled = false;
        }
        if (noReplyAndCatCheck) {
            if (noReplyAndCatCheck.checked) noReplyAndCatBadge.style.display = "block";
            if (!noReplyAndCatCheck.checked) {
                noReplyAndCatBadge.style.display = "none";
                cleanChoice.splice(cleanChoice.indexOf("NOREPLYANDCAT"));
            }
            noReplyAndCatCheck.disabled = false;
        }
        if (catDupsCheck) {
            if (catDupsCheck.checked) catDupsBadge.style.display = "block";
            if (!catDupsCheck.checked) {
                catDupsBadge.style.display = "none";
                cleanChoice.splice(cleanChoice.indexOf("CATDUPS"));
            }
            catDupsCheck.disabled = false;
        }
        btnClean.disabled = true;
        btnIgnore.disabled = true;
    }
}
// CHECK CLEANING OPTION FUNCTION END

// DIALOG CLEAN BUTTON FUNCTION START
function dialogClean() {
    return new Promise((resolve, reject) => {
        for (let i = 0; i < checkList.length; i++) {
            for (let c = 0; c < cleanChoice.length; c++) {
                // clear empty records start
                if (cleanChoice[c] === "EMPTY") {
                    if (checkList[i].problemType === "EMPTY") {
                        if (i !== checkList.length - 1) {
                            recordsChats.splice(checkList[i].rmvPosChats, 1);
                            allRecords.splice(checkList[i].rmvPosAllList, 1);
                            checkList[i + 1].rmvPosChats -= 1
                            checkList[i + 1].rmvPosAllList -= 1;
                        }
                        if (i === checkList.length - 1) {
                            recordsChats.splice(checkList[i].rmvPosChats, 1);
                            allRecords.splice(checkList[i].rmvPosAllList, 1);
                        }
                    }
                }
                // clear empty records end

                // clear no reply and category records start
                if (cleanChoice[c] === "NOREPLYANDCAT") {
                    if (checkList[i].problemType === "NOREPLYANDCAT") {
                        if (i !== checkList.length - 1) {
                            recordsChats.splice(checkList[i].rmvPosChats, 1);
                            allRecords.splice(checkList[i].rmvPosAllList, 1);
                            checkList[i + 1].rmvPosChats -= 1
                            checkList[i + 1].rmvPosAllList -= 1;
                        }
                        if (i === checkList.length - 1) {
                            recordsChats.splice(checkList[i].rmvPosChats, 1);
                            allRecords.splice(checkList[i].rmvPosAllList, 1);
                        }
                    }
                }
                // clear no reply and category records end

                // clear category dups records start
                if (cleanChoice[c] === "CATDUPS") {
                    if (checkList[i].problemType === "CATDUPS") {
                        if (i !== checkList.length - 1) {
                            recordsChats.splice(checkList[i].rmvPosChats, 1);
                            allRecords.splice(checkList[i].rmvPosAllList, 1);
                            checkList[i + 1].rmvPosChats -= 1
                            checkList[i + 1].rmvPosAllList -= 1;
                        }
                        if (i === checkList.length - 1) {
                            recordsChats.splice(checkList[i].rmvPosChats, 1);
                            allRecords.splice(checkList[i].rmvPosAllList, 1);
                        }
                    }
                }
                // clear category dups records end
            }
        }
        cleaningCheck.checked = false;
        dialogContainer.classList.toggle('hide');
        resolve(buildFilteringSection());
    })
}
// DIALOG CLEAN BUTTON FUNCTION END

// DIALOG IGNORE BUTTON FUNCTION START
function dialogIgnore() {
    new Promise((resolve, reject) => {
        dialogContainer.classList.toggle('hide');
        cleaningCheck.checked = false;
        resolve(buildFilteringSection());
    })
}
// DIALOG IGNORE BUTTON FUNCTION END

// BUILD REPORT SECTION FUNCTION START
let buildReportOptionArr = {};
async function buildReportSection() {
    let reportContainer = getE(".report-container");
    reportContainer.style.opacity = '1';
    reportContainer.style.height = '49%';
    // reportContainer.style.padding = '15px 20px';
    // reportContainer.style.display = 'block';
    let addContent = "";
    reportContainer.innerHTML = `
            <div><h2>Сформувати очищені звіти:</h2><p class="info-icon">i</p><div class="info-message">
            <p>На основі оброблених данних з ваших звітім можна сформувати типізовані звіти:<br>
            - по чатах;<br>
            - тікетах;<br>
            - загальний (чати та тікети разом);<br>
            - звіт з неправильно проставленими мітками.<br>
            Для того щоб завантажити звіт потрібно спочатку створити відповідний кнопкою "Створити". Коли звіт буде готовий кнопка "Завантажити" стане активною.<br>
            В результаті завантаження ви отримаєте потрібний файл/и у форматі .csv.</p></div></div>`;
    for (let i = 0; i < Object.keys(buildReportOptionArr).length; i++) {
        if (Object.keys(buildReportOptionArr)[i] === "recordsChats") {
            addContent = `<fieldset>
            <legend>- по чатах</legend>
            <input type="button" id="createChatReport" 
            onclick="createReport(recordsChats,'chat')" value="Створити">
            <button disabled><a id="downloadChatReport">Завантажити</a></button>
            </fieldset>`
        }
        reportContainer.innerHTML += addContent;
        addContent = "";
        if (Object.keys(buildReportOptionArr)[i] === "recordsTickets") {
            addContent = `<fieldset>
            <legend>- по тікетах</legend>
            <input type="button" id="createTicketReport" 
            onclick="createReport(recordsTickets,'ticket')" value="Створити">
            <button disabled><a id="downloadTicketReport">Завантажити</a></button>
            </fieldset>`
        }
        reportContainer.innerHTML += addContent;
        addContent = "";
        if (Object.keys(buildReportOptionArr)[i] === "allRecords") {
            addContent = `<fieldset>
            <legend>- спільний звіт</legend>
            <input type="button" id="createGeneralReport" 
            onclick="createReport(allRecords,'general')" value="Створити">
            <button disabled><a id="downloadGeneralReport">Завантажити</a></button>
            </fieldset>`
        }
        reportContainer.innerHTML += addContent;
        addContent = "";
        if (Object.keys(buildReportOptionArr)[i] === "checkList") {
            addContent = `<fieldset>
            <legend>- звернення на перевірку</legend>
            <input type="button" id="createCheckReport" 
            onclick="createReport(checkList,'check')" value="Створити">
            <button disabled><a id="downloadCheckReport">Завантажити</a></button>
            </fieldset>`
        }
        reportContainer.innerHTML += addContent;
    }
}
// BUILD REPORT SECTION FUNCTION END

// GENERATE REPORT FUNCTION START
let reportName;
async function createReport(recordsForReport, reportType) {
    return new Promise((resolve) => {
        let csv = "";
        let fRow = false;
        for (let row = 0; row < recordsForReport.length; row++) {
            if (reportType === "check") {
                delete recordsForReport[row].rmvPosChats;
                delete recordsForReport[row].rmvPosTickets;
                delete recordsForReport[row].rmvPosAllList;
            }
            else {
                delete recordsForReport[row].specialFields;
            }
            let keysAmount = Object.keys(recordsForReport[row]).length;
            let keysCounter = 0;
            if (row === 0) {
                for (let key in recordsForReport[row]) {
                    let dataToSet = "\"" + key + "\"";
                    csv += dataToSet + (keysCounter + 1 < keysAmount ? ',' : '\r\n');
                    keysCounter++;
                    fRow = true;
                }
            }
            keysCounter = 0;
            if (row === 0 && fRow) {
                for (let key in recordsForReport[row]) {
                    let dataToSet = "\"" + (Array.isArray(recordsForReport[row][key]) ? recordsForReport[row][key].join(";") : recordsForReport[row][key]) + "\"";
                    csv += dataToSet + (keysCounter + 1 < keysAmount ? ',' : '\r\n');
                    keysCounter++;
                }
            }
            else {
                for (let key in recordsForReport[row]) {
                    let dataToSet = "\"" + (Array.isArray(recordsForReport[row][key]) ? recordsForReport[row][key].join(";") : recordsForReport[row][key]) + "\"";
                    csv += dataToSet + (keysCounter + 1 < keysAmount ? ',' : '\r\n');
                    keysCounter++;
                }
            }
            keysCounter = 0;
        }
        let setToButton;
        let reportDateTime = new Date().toLocaleString("uk-UA");
        if (reportType === "chat") {
            reportName = "CHAT_report_" + reportDateTime.replace(",", "");
            setToButton = getE('#downloadChatReport');
        }
        if (reportType === "ticket") {
            reportName = "TICKET_report_" + reportDateTime.replace(",", "");
            setToButton = getE('#downloadTicketReport');
        }
        if (reportType === "general") {
            reportName = "GENERAL_report_" + reportDateTime.replace(",", "");
            setToButton = getE('#downloadGeneralReport');
        }
        if (reportType === "check") {
            reportName = "CHECK_report_" + reportDateTime.replace(",", "");
            setToButton = getE('#downloadCheckReport');
        }
        if (reportType === "filteredData") {
            reportName = "FILTERED_report_" + reportDateTime.replace(",", "");
            setToButton = false;

        }

        if (!setToButton) {
            let link = document.createElement('a');
            // link.innerHTML = 'Button';
            link.id = 'download-csv';
            link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(csv));
            link.setAttribute('download', `${reportName}.csv`);
            document.body.appendChild(link)
            document.querySelector("#download-csv").click()
        }
        else {
            setToButton.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(csv));
            setToButton.setAttribute('download', `${reportName}.csv`);
            resolve(setToButton.parentNode.disabled = false);
        }
    })

}
// GENERATE REPORT FUNCTION END

// DATA TABLE SHOW/HIDE EFFECT FUNCTION START
let menu = document.querySelector('.menu'),
    content = document.querySelector('.content');
menu.onclick = (e) => {
    for (let elem = 0; elem < menu.children.length; elem++) {
        if (menu.children[elem].id === e.target.id) {
            menu.children[elem].classList.add('active');
            let idNum = e.target.id.substring(e.target.id.length - 1);
            for (let conElem = 0; conElem < content.children.length; conElem++) {
                if (content.children[conElem].id === `data-table-${idNum}`) content.children[conElem].classList.add('show');
                else content.children[conElem].classList.remove('show');
            }
        }
        else menu.children[elem].classList.remove('active');
    }
}
// DATA TABLE SHOW/HIDE EFFECT FUNCTION END

// getE('.start-instraction-block').style.display = "none";
// getE('.data-main').classList.remove("hide");
// getE('.counter-number').innerHTML = allRecords.length;
// getE('.counter-header').style.display = "block";
// buildFilteringSection();
// showAndBuildDialog(checkList);

// RESET FILTERS BUTTON FUNCTION START
async function resetFilters() {
    await buildFilteringSection();
}
// RESET FILTERS BUTTON FUNCTION END

// SHOW DATA TABLE CONTAINER FUCNTION START
function showDataTable() {
    getE('.display-data-container').classList.remove('hide');
}
// SHOW DATA TABLE CONTAINER FUCNTION END

async function renderResults(isFirst) {
    let tHead = getE('.data-table > thead'),
        tBody = getE('.data-table > tbody');

    let recordsToRenderArr = [];
    (isFirst) ? recordsToRenderArr = allRecords : recordsToRenderArr = filteredDataArr;

    // await buildObjForTableDisplay(recordsToRenderArr);

    // tHead.innerHTML = "";
    // tHead.innerHTML = `<tr>
    //     <th>Проєкт</th>
    //     <th>Тип звернення</th>
    //     <th>Категорія</th>
    //     <th>Керування</th>
    //     </tr>`

    // console.log(buildedFilter.projectsFilter);
    let saveLength = 0, projectSpan;

    let rowsCount = 0, projectsSpans = {}, convTypesSpans = {};
    for (const keyLvl1 in tableDataObj) {
        for (const keyLvl2 in tableDataObj[keyLvl1]) { // project INDEXes
            let tableLvl1 = tableDataObj[keyLvl1];
            for (const keyLvl3 in tableLvl1[keyLvl2]) { // project NAMEs
                let tableLvl2 = tableLvl1[keyLvl2];
                for (const keyLvl4 in tableLvl2[keyLvl3]) { // conversation type INDEXes
                    let tableLvl3 = tableLvl2[keyLvl3];
                    for (const keyLvl5 in tableLvl3[keyLvl4]) { // categories array level
                        let tableLvl4 = tableLvl3[keyLvl4];
                        (keyLvl5 === 'chat') ?
                            saveLength = tableLvl4[keyLvl5].length :
                            projectSpan = saveLength + tableLvl4[keyLvl5].length;
                        projectsSpans[`_${keyLvl3}`] = projectSpan;
                        projectSpan = 0;
                        convTypesSpans[`_${keyLvl3}${proper(keyLvl5)}`] = tableLvl4[keyLvl5].length;
                        rowsCount += tableLvl4[keyLvl5].length;
                    }
                }
            }
        }
    }
    // console.log('Rows Count = ', rowsCount);
    // console.log('convTypesSpans = ', convTypesSpans);
    // console.log('projectsSpans = ', projectsSpans);
    let setToRow = 0;
    // tBody.innerHTML = "";
    // for (let row = 0; row < rowsCount; row++) {
    //     tBody.innerHTML += `<tr></tr>`;
    // }
    let limit = 250

    for (let record = 0; record < recordsToRenderArr.length; record++) {
        // tBody.innerHTML += `
        // <tr>
        // <td>${record}</td>
        // <td>${recordsToRenderArr[record].conversationType}</td>
        // <td>${recordsToRenderArr[record].conversationCategory}</td>
        // <td>${recordsToRenderArr[record].operatorNicks}</td>
        // </tr>`
        if (record === limit) {
            break;
        }
    }

    // for (let record = 0; record < recordsToRenderArr.length; record++) {
    //     for (const keyProjSpan in projectsSpans) {
    //         for (let project = 0; project < buildedFilter.projectsFilter.length; project++) {
    //             if (record === projectsSpans[keyProjSpan] - 1 &&
    //                 "_" + buildedFilter.projectsFilter[project] === keyProjSpan) {
    //                 for (let row = 0; row < tBody.children.length; row++) {
    //                     if (tBody.children[row].firstElementChild !== null) {
    //                         setToRow += tBody.children[row].firstElementChild.rowSpan
    //                     }
    //                 }
    //                 // console.log("ENTER -> set to row", setToRow, "#", tBody.children[record].id, "span =", projectsSpans[keyProjSpan]);
    //                 tBody.children[setToRow].innerHTML =
    //                     `<td rowspan="${projectsSpans[keyProjSpan]}">${keyProjSpan.slice(1)}</td>`;
    //                 setToRow = 0;
    //             }
    //         }
    //     }
    // }




    // `;



    // document.querySelector('.data-table > tbody').childElementCount;
    // console.log(tBody.children[0].firstElementChild.rowSpan = projectsSpans._KatsuBet);


    // console.log(buildedFilter);

}

function buildHeader() {
    let theadEl = document.getElementById('tblcsvdata').getElementsByTagName('thead')[0];
    let dataForTHead = dataByRecords[0].substring(1, dataByRecords[0].length - 1).split('","');
    theadEl.innerHTML = "";

    // conferenceId
    // conversationLink
    // conversationTags
    // conversationType
    // createdAt
    // customerEmail
    // customerId
    // projectName

    theadEl.innerHTML = `<tr><th>${dataForTHead[0]}</th>
                <th>${dataForTHead[1]}</th>
                <th>${dataForTHead[2]}</th>
                <th>${dataForTHead[3]}</th>
                <th>${dataForTHead[4]}</th>
                <th>${dataForTHead[5]}</th>
                <th>${dataForTHead[6]}</th>
                <th>${dataForTHead[7]}</th>
                <th>${dataForTHead[8]}</th>
                <th>${dataForTHead[9]}</th>
                <th>${dataForTHead[10]}</th>
                <th>${dataForTHead[11]}</th>
                <th>${dataForTHead[12]}</th>
                <th>${dataForTHead[13]}</th>
                <th>${dataForTHead[14]}</th>
                <th>${dataForTHead[15]}</th>
                <th>${dataForTHead[16]}</th>
                <th>${dataForTHead[17]}</th></tr>`
}